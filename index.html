<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OC Scanner • Multiviewer</title>
  <style>
    :root {
      --bg: #0b0f14;
      --card: #0f1720;
      --muted: #9aa;
      --accent: #0a84ff;
      --text: #eef;
    }
    html,body{height:100%}
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      margin:0;
      padding:0;
      background:var(--bg);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    .ticker {
      background: linear-gradient(90deg, #0a84ff 0%, #0066cc 100%);
      color: white;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.9rem;
      font-weight: 500;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      gap: 16px;
      flex-wrap: wrap;
    }
    .ticker-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .ticker-label {
      opacity: 0.9;
      font-size: 0.85rem;
    }
    .ticker-value {
      font-weight: 600;
    }
    .content-wrapper {
      padding: 16px;
    }
    header { display:flex; align-items:center; gap:12px; margin-bottom:12px; flex-wrap:wrap }
    h1 { font-size:1.1rem; margin:0 }
    .note { color:var(--muted); font-size:0.9rem }
    .groups { display:grid; grid-template-columns:repeat(auto-fit,minmax(320px,1fr)); gap:12px }
    .group { background:var(--card); border:1px solid rgba(255,255,255,0.03); padding:12px; border-radius:8px }
    .group h2 { margin:0 0 8px 0; font-size:1rem; color:var(--text) }
    .channel { display:flex; gap:12px; align-items:flex-start; margin-bottom:12px }
    .thumb { width:160px; height:90px; background:#000; display:flex; align-items:center; justify-content:center; color:#999; border-radius:6px; overflow:hidden; flex:0 0 160px; }
    .thumb img{width:100%; height:100%; object-fit:cover; display:block}
    .meta { flex:1; min-width:0 }
    .meta .name { font-weight:600; margin-bottom:6px; word-break:break-word }
    .meta .actions { display:flex; gap:8px; align-items:center }
    button.play { background:var(--accent); color:white; border:0; padding:8px 10px; border-radius:6px; cursor:pointer; font-weight:600 }
    a.fallback { color:#9cc; font-size:0.9rem; text-decoration:none }
    .small { font-size:0.85rem; color:var(--muted) }
    .iframe-wrap { width:100%; max-width:100%; border-radius:6px; overflow:hidden; background:#000; }
    .blocked { color:#f88; font-weight:600; }
    footer { margin-top:18px; color:var(--muted); font-size:0.85rem }
  </style>
</head>
<body>
  <div class="ticker">
    <div class="ticker-item">
      <span class="ticker-label">Local Time:</span>
      <span class="ticker-value" id="local-time">--:--:--</span>
    </div>
    <div class="ticker-item">
      <span class="ticker-label">UTC:</span>
      <span class="ticker-value" id="utc-time">--:--:--</span>
    </div>
    <div class="ticker-item">
      <span class="ticker-label">OC Weather:</span>
      <span class="ticker-value" id="weather-info">Loading...</span>
    </div>
  </div>

  <div class="content-wrapper">
    <header>
      <h1 id="title">Multiviewer</h1>
      <div class="note">Click Play to load a stream (lazy-loaded to save CPU & bandwidth). Use "Open in new tab" if embedding is blocked.</div>
    </header>

    <main>
      <div id="groups" class="groups" aria-live="polite"></div>
      <footer>
        Note: Some sites prevent embedding (X-Frame-Options or CSP). If a stream doesn't load, open it directly.
      </footer>
    </main>
  </div>

  <!-- channels.js will be fetched with cache: 'no-cache' to avoid stale cached copies -->
  <script>
    // Ticker functionality - Time and Weather updates
    (function() {
      // Configuration constants
      const OC_LAT = 33.7175;
      const OC_LON = -117.8311;
      const WEATHER_UPDATE_INTERVAL = 10 * 60 * 1000; // 10 minutes
      const TIME_UPDATE_INTERVAL = 1000; // 1 second
      
      // WMO weather codes to descriptions mapping
      const WEATHER_CODES = {
        0: 'Clear', 1: 'Mainly Clear', 2: 'Partly Cloudy', 3: 'Overcast',
        45: 'Foggy', 48: 'Foggy', 51: 'Light Drizzle', 53: 'Drizzle', 55: 'Heavy Drizzle',
        61: 'Light Rain', 63: 'Rain', 65: 'Heavy Rain', 71: 'Light Snow', 73: 'Snow', 75: 'Heavy Snow',
        77: 'Snow Grains', 80: 'Light Showers', 81: 'Showers', 82: 'Heavy Showers',
        85: 'Light Snow Showers', 86: 'Snow Showers', 95: 'Thunderstorm', 96: 'Thunderstorm', 99: 'Thunderstorm'
      };
      
      // Update time displays
      function updateTime() {
        const now = new Date();
        
        // Local time
        const localTimeStr = now.toLocaleTimeString('en-US', { 
          hour12: true, 
          hour: '2-digit', 
          minute: '2-digit', 
          second: '2-digit' 
        });
        document.getElementById('local-time').textContent = localTimeStr;
        
        // UTC time
        const utcTimeStr = now.toLocaleTimeString('en-US', { 
          timeZone: 'UTC',
          hour12: true, 
          hour: '2-digit', 
          minute: '2-digit', 
          second: '2-digit' 
        });
        document.getElementById('utc-time').textContent = utcTimeStr;
      }
      
      // Fetch OC weather data
      async function updateWeather() {
        const weatherEl = document.getElementById('weather-info');
        try {
          // Using Open-Meteo API which is free, no API key required, and CORS-friendly
          const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${OC_LAT}&longitude=${OC_LON}&current_weather=true&temperature_unit=fahrenheit`);
          const data = await response.json();
          
          if (data && data.current_weather) {
            const current = data.current_weather;
            const temp = Math.round(current.temperature);
            const desc = WEATHER_CODES[current.weathercode] || 'Unknown';
            weatherEl.textContent = `${temp}°F, ${desc}`;
          } else {
            weatherEl.textContent = 'Weather data unavailable';
          }
        } catch (error) {
          console.error('Weather fetch error:', error);
          weatherEl.textContent = 'Weather unavailable';
        }
      }
      
      // Initialize ticker
      updateTime();
      updateWeather();
      
      // Update time every second
      setInterval(updateTime, TIME_UPDATE_INTERVAL);
      
      // Update weather every 10 minutes
      setInterval(updateWeather, WEATHER_UPDATE_INTERVAL);
    })();
  </script>
  <script>
    (async function(){
      try {
        const res = await fetch('channels.js', { cache: 'no-cache' });
        const txt = await res.text();
        if (txt && txt.indexOf('window.CHANNEL_GROUPS') !== -1) {
          const s = document.createElement('script');
          s.type = 'text/javascript';
          s.textContent = txt;
          document.head.appendChild(s);
          // notify any listeners that channels have been injected
          document.dispatchEvent(new Event('channels-loaded'));
        } else {
          const s = document.createElement('script');
          s.src = 'channels.js';
          s.onload = () => document.dispatchEvent(new Event('channels-loaded'));
          document.head.appendChild(s);
          console.warn('channels.js fetched but content looks invalid; falling back to standard include.');
        }
      } catch (err) {
        const s = document.createElement('script');
        s.src = 'channels.js';
        s.onload = () => document.dispatchEvent(new Event('channels-loaded'));
        document.head.appendChild(s);
        console.error('Failed to load channels.js via fetch, falling back to <script src="channels.js">:', err);
      }
    })();
  </script>

  <script>
    // Render + embedding logic
    const titleEl = document.getElementById('title');
    if (window.APP_CONFIG && window.APP_CONFIG.title) titleEl.textContent = window.APP_CONFIG.title;

    const groupsContainer = document.getElementById('groups');

    function extractYoutubeId(url) {
      if (!url) return null;
      const patterns = [
        /youtube\.com\/embed\/([A-Za-z0-9_\-]+)/,
        /youtube\.com\/watch\?v=([A-Za-z0-9_\-]+)/,
        /youtu\.be\/([A-Za-z0-9_\-]+)/,
        /v=([A-Za-z0-9_\-]+)/,
      ];
      for (const p of patterns) {
        const m = url.match(p);
        if (m && m[1]) return m[1];
      }
      return null;
    }

    function makeThumbnail(channel) {
      const wrapper = document.createElement('div');
      wrapper.className = 'thumb';
      if (channel.type === 'youtube') {
        const id = extractYoutubeId(channel.url);
        if (id) {
          const img = document.createElement('img');
          img.src = `https://i.ytimg.com/vi/${id}/hqdefault.jpg`;
          img.alt = (channel.name || 'YouTube thumbnail') + ' thumbnail';
          wrapper.appendChild(img);
          return wrapper;
        }
      }
      wrapper.textContent = 'Preview';
      return wrapper;
    }

    function createIframe(channel) {
      const iframe = document.createElement('iframe');
      iframe.src = channel.url;
      iframe.title = channel.name || 'Video channel';
      iframe.loading = 'eager';
      iframe.width = 560;
      iframe.height = 315;
      iframe.style.width = '100%';
      iframe.style.height = '360px';
      iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; autoplay');
      iframe.allowFullscreen = true;
      iframe.setAttribute('referrerpolicy', 'no-referrer-when-downgrade');
      iframe.style.border = '0';
      return iframe;
    }

    function renderChannels() {
      const CHANNELS = window.CHANNEL_GROUPS || {};
      groupsContainer.innerHTML = ''; // clear first
      Object.keys(CHANNELS).forEach(key => {
        const group = CHANNELS[key];
        const groupEl = document.createElement('section');
        groupEl.className = 'group';
        const h = document.createElement('h2');
        h.textContent = group.label || key;
        groupEl.appendChild(h);

        (group.channels || []).forEach(channel => {
          const row = document.createElement('div');
          row.className = 'channel';

          const thumbWrap = document.createElement('div');
          const thumb = makeThumbnail(channel);
          thumbWrap.appendChild(thumb);

          const meta = document.createElement('div');
          meta.className = 'meta';
          const name = document.createElement('div');
          name.className = 'name';
          name.textContent = channel.name || 'Unnamed channel';

          const actions = document.createElement('div');
          actions.className = 'actions';

          const play = document.createElement('button');
          play.className = 'play';
          play.textContent = 'Play';
          play.type = 'button';

          const open = document.createElement('a');
          open.className = 'fallback';
          open.href = channel.url || '#';
          open.target = '_blank';
          open.rel = 'noopener noreferrer';
          open.textContent = 'Open in new tab';

          const small = document.createElement('div');
          small.className = 'small';
          small.textContent = channel.type ? channel.type : '';

          play.addEventListener('click', () => {
            const frameWrap = document.createElement('div');
            frameWrap.className = 'iframe-wrap';
            const loadingNote = document.createElement('div');
            loadingNote.className = 'small';
            loadingNote.textContent = 'Loading…';
            frameWrap.appendChild(loadingNote);

            thumbWrap.replaceChild(frameWrap, thumbWrap.firstChild);

            const iframe = createIframe(channel);

            let loaded = false;
            iframe.addEventListener('load', () => {
              loaded = true;
            });

            frameWrap.replaceChild(iframe, loadingNote);

            setTimeout(() => {
              if (!loaded) {
                const blocked = document.createElement('div');
                blocked.innerHTML = '<div class="blocked">Embedding appears to be blocked by the source.</div>';
                const openNow = document.createElement('a');
                openNow.href = channel.url || '#';
                openNow.target = '_blank';
                openNow.rel = 'noopener noreferrer';
                openNow.className = 'fallback';
                openNow.textContent = 'Open directly in a new tab';
                blocked.appendChild(openNow);
                frameWrap.replaceChild(blocked, iframe);
              }
            }, 3000);
          });

          const popout = document.createElement('button');
          popout.className = 'play';
          popout.textContent = 'Popout';
          popout.type = 'button';
          popout.style.background = '#2f2f2f';
          popout.addEventListener('click', () => {
            const url = 'player.html?src=' + encodeURIComponent(channel.url);
            window.open(url, '_blank', 'noopener,noreferrer');
          });

          const focus = document.createElement('button');
          focus.className = 'play';
          focus.textContent = 'Focus';
          focus.type = 'button';
          focus.style.background = '#444';
          focus.addEventListener('click', () => {
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = 0;
            overlay.style.background = 'black';
            overlay.style.zIndex = 2147483647;
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';

            const frameWrap = document.createElement('div');
            frameWrap.style.width = '100%';
            frameWrap.style.maxWidth = '1280px';
            frameWrap.style.height = '100%';
            frameWrap.style.display = 'flex';
            frameWrap.style.alignItems = 'center';
            frameWrap.style.justifyContent = 'center';

            const iframe = createIframe(channel);
            iframe.style.height = '100%';
            iframe.style.maxHeight = '100vh';
            iframe.style.width = '100%';
            iframe.style.maxWidth = '100%';
            frameWrap.appendChild(iframe);

            const close = document.createElement('button');
            close.textContent = '\u00d7';
            close.title = 'Close';
            close.style.position = 'absolute';
            close.style.right = '14px';
            close.style.top = '10px';
            close.style.fontSize = '28px';
            close.style.background = 'transparent';
            close.style.color = '#fff';
            close.style.border = 'none';
            close.style.cursor = 'pointer';
            close.style.zIndex = 2147483648;
            close.addEventListener('click', () => {
              try { if (document.fullscreenElement) document.exitFullscreen(); } catch(e) {}
              overlay.remove();
            });

            overlay.appendChild(frameWrap);
            overlay.appendChild(close);
            document.body.appendChild(overlay);

            if (overlay.requestFullscreen) overlay.requestFullscreen().catch(()=>{});
          });

          const openBtn = open;

          const actionsContainer = document.createElement('div');
          actionsContainer.className = 'meta-actions';
          actionsContainer.appendChild(play);
          actionsContainer.appendChild(focus);
          actionsContainer.appendChild(popout);
          actionsContainer.appendChild(openBtn);

          actions.appendChild(actionsContainer);

          meta.appendChild(name);
          meta.appendChild(actions);
          meta.appendChild(small);

          row.appendChild(thumbWrap);
          row.appendChild(meta);
          groupEl.appendChild(row);
        });

        groupsContainer.appendChild(groupEl);
      });
    }

    // Initialization: wait for channels to be available, then render.
    function initWhenChannelsReady(timeoutMs = 10000) {
      console.debug('initWhenChannelsReady called');
      // If channels are already present, render immediately.
      if (window.CHANNEL_GROUPS && Object.keys(window.CHANNEL_GROUPS).length > 0) {
        renderChannels();
        return;
      }

      // Listen for explicit event from loader.
      const onLoaded = () => {
        try { renderChannels(); } catch(e){ console.error(e); }
        cleanup();
      };

      function cleanup(){
        document.removeEventListener('channels-loaded', onLoaded);
        if (pollHandle) clearInterval(pollHandle);
      }

      document.addEventListener('channels-loaded', onLoaded);

      // Poll as a fallback (in case event fired before listener or loader didn't dispatch)
      const start = Date.now();
      const pollHandle = setInterval(() => {
        if (window.CHANNEL_GROUPS && Object.keys(window.CHANNEL_GROUPS).length > 0) {
          renderChannels();
          cleanup();
        } else if (Date.now() - start > timeoutMs) {
          // Give up after timeout: show helpful message
          groupsContainer.textContent = 'No channels configured or channels failed to load.';
          cleanup();
        }
      }, 200);
    }

    // Expose functions globally so manual calls and debugging from console work.
    window.renderChannels = renderChannels;
    window.initWhenChannelsReady = initWhenChannelsReady;

    // Kick off initialization (also available as window.initWhenChannelsReady)
    window.initWhenChannelsReady();
  </script>
</body>
</html>